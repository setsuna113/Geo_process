-- Storage layer for spatial biodiversity analysis pipeline

-- Enable PostGIS extension
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Grid definitions table
-- Stores metadata for different grid systems generated by grid_systems/ modules
CREATE TABLE grids (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    grid_type VARCHAR(20) NOT NULL, -- 'cubic', 'hexagonal'
    resolution INTEGER NOT NULL,     -- Resolution parameter (meters for cubic, H3 level for hex)
    crs VARCHAR(20) NOT NULL,       -- CRS used for generation ('EPSG:3857', 'EPSG:4326')
    bounds GEOMETRY(POLYGON, 4326), -- Study area bounds (always WGS84)
    total_cells INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB DEFAULT '{}',    -- Store additional grid parameters
    
    UNIQUE(name),
    CHECK(grid_type IN ('cubic', 'hexagonal')),
    CHECK(crs IN ('EPSG:3857', 'EPSG:4326'))
);

-- Grid cells table
-- Stores individual cells generated by CubicGrid/HexagonalGrid classes
CREATE TABLE grid_cells (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    grid_id UUID REFERENCES grids(id) ON DELETE CASCADE,
    cell_id VARCHAR(100) NOT NULL,   -- H3 index or custom identifier
    geometry GEOMETRY(POLYGON, 4326) NOT NULL,
    area_km2 FLOAT,
    centroid GEOMETRY(POINT, 4326),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(grid_id, cell_id)
);

-- Species range data table
-- Stores raw species distribution data loaded from .gpkg files
CREATE TABLE species_ranges (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    species_name VARCHAR(200) NOT NULL,
    scientific_name VARCHAR(200),
    genus VARCHAR(100),
    family VARCHAR(100),
    order_name VARCHAR(100),
    class_name VARCHAR(100),
    phylum VARCHAR(100),
    kingdom VARCHAR(100),
    category VARCHAR(50) DEFAULT 'unknown', -- Classified by species/classifier.py
    range_type VARCHAR(50) DEFAULT 'distribution', -- 'distribution', 'breeding', 'wintering'
    geometry GEOMETRY(GEOMETRY, 4326) NOT NULL, -- Original geometry from .gpkg (POLYGON/MULTIPOLYGON)
    source_file VARCHAR(500) NOT NULL,
    source_dataset VARCHAR(200),
    confidence FLOAT DEFAULT 1.0,
    area_km2 FLOAT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB DEFAULT '{}',
    
    CHECK(category IN ('plant', 'animal', 'fungi', 'unknown')),
    CHECK(confidence BETWEEN 0 AND 1)
);

-- Species-grid intersections table
-- Stores results from spatial intersection calculations (processors/intersection_calculator.py)
CREATE TABLE species_grid_intersections (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    grid_id UUID REFERENCES grids(id) ON DELETE CASCADE,
    cell_id VARCHAR(100) NOT NULL,
    species_range_id UUID REFERENCES species_ranges(id) ON DELETE CASCADE,
    species_name VARCHAR(200) NOT NULL,
    category VARCHAR(50) NOT NULL,
    range_type VARCHAR(50) NOT NULL,
    intersection_area_km2 FLOAT,
    coverage_percent FLOAT, -- Percentage of grid cell covered by species range
    presence_score FLOAT DEFAULT 1.0, -- Weighted presence (0-1)
    computed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    computation_metadata JSONB DEFAULT '{}',
    
    UNIQUE(grid_id, cell_id, species_range_id),
    CHECK(category IN ('plant', 'animal', 'fungi', 'unknown')),
    CHECK(coverage_percent BETWEEN 0 AND 100),
    CHECK(presence_score BETWEEN 0 AND 1)
);

-- Features table
-- Stores computed features from features/ modules (richness, climate, interactions)
CREATE TABLE features (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    grid_id UUID REFERENCES grids(id) ON DELETE CASCADE,
    cell_id VARCHAR(100) NOT NULL,
    feature_type VARCHAR(50) NOT NULL, -- 'richness', 'climate', 'interaction', 'derived'
    feature_name VARCHAR(100) NOT NULL, -- 'present_richness', 'bio_1', 'P_x_T', etc.
    feature_value FLOAT NOT NULL,
    computed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    computation_metadata JSONB DEFAULT '{}', -- Store computation parameters
    
    UNIQUE(grid_id, cell_id, feature_type, feature_name)
);

-- Climate data table
-- Stores extracted climate variables (features/climate_features.py)
CREATE TABLE climate_data (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    grid_id UUID REFERENCES grids(id) ON DELETE CASCADE,
    cell_id VARCHAR(100) NOT NULL,
    variable VARCHAR(20) NOT NULL,  -- 'bio_1', 'bio_12', etc.
    value FLOAT NOT NULL,
    source VARCHAR(100), -- 'WorldClim_v2.1', etc.
    resolution VARCHAR(20), -- '10m', '5m', '2.5m'
    extracted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(grid_id, cell_id, variable, source, resolution)
);

-- Experiments table
-- Tracks experimental runs and configurations (pipeline/orchestrator.py)
CREATE TABLE experiments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    config JSONB NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    results JSONB DEFAULT '{}',
    error_message TEXT,
    created_by VARCHAR(100),
    
    UNIQUE(name),
    CHECK(status IN ('pending', 'running', 'completed', 'failed', 'cancelled'))
);

-- Processing jobs table
-- Tracks long-running processing operations with progress
CREATE TABLE processing_jobs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    job_type VARCHAR(50) NOT NULL, -- 'grid_generation', 'species_intersection', 'feature_computation'
    job_name VARCHAR(200),
    status VARCHAR(20) DEFAULT 'pending',
    parameters JSONB NOT NULL,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    progress_percent FLOAT DEFAULT 0,
    log_messages TEXT[] DEFAULT '{}',
    error_message TEXT,
    parent_experiment_id UUID REFERENCES experiments(id),
    
    CHECK(status IN ('pending', 'running', 'completed', 'failed', 'cancelled')),
    CHECK(progress_percent BETWEEN 0 AND 100)
);

-- Spatial indexes for performance
CREATE INDEX idx_grid_cells_geometry ON grid_cells USING GIST (geometry);
CREATE INDEX idx_grid_cells_centroid ON grid_cells USING GIST (centroid);
CREATE INDEX idx_species_ranges_geometry ON species_ranges USING GIST (geometry);

-- Regular indexes for common queries
CREATE INDEX idx_grids_type_resolution ON grids (grid_type, resolution);
CREATE INDEX idx_grids_name ON grids (name);
CREATE INDEX idx_grid_cells_grid_id ON grid_cells (grid_id);
CREATE INDEX idx_grid_cells_cell_id ON grid_cells (grid_id, cell_id);
CREATE INDEX idx_species_ranges_category ON species_ranges (category);
CREATE INDEX idx_species_ranges_species ON species_ranges (species_name);
CREATE INDEX idx_species_ranges_source ON species_ranges (source_file);
CREATE INDEX idx_species_intersections_grid_cell ON species_grid_intersections (grid_id, cell_id);
CREATE INDEX idx_species_intersections_species ON species_grid_intersections (species_name);
CREATE INDEX idx_species_intersections_category ON species_grid_intersections (category);
CREATE INDEX idx_features_grid_cell ON features (grid_id, cell_id);
CREATE INDEX idx_features_type_name ON features (feature_type, feature_name);
CREATE INDEX idx_climate_grid_cell ON climate_data (grid_id, cell_id);
CREATE INDEX idx_climate_variable ON climate_data (variable);
CREATE INDEX idx_experiments_status ON experiments (status);
CREATE INDEX idx_experiments_created ON experiments (started_at);
CREATE INDEX idx_jobs_type_status ON processing_jobs (job_type, status);
CREATE INDEX idx_jobs_experiment ON processing_jobs (parent_experiment_id);

-- Utility views for common aggregations
CREATE VIEW species_richness_summary AS
SELECT 
    sgi.grid_id,
    sgi.cell_id,
    sgi.category,
    sgi.range_type,
    COUNT(DISTINCT sgi.species_name) as species_count,
    AVG(sgi.coverage_percent) as avg_coverage,
    SUM(sgi.intersection_area_km2) as total_intersection_area,
    AVG(sgi.presence_score) as avg_presence_score
FROM species_grid_intersections sgi
GROUP BY sgi.grid_id, sgi.cell_id, sgi.category, sgi.range_type;

CREATE VIEW grid_processing_status AS
SELECT 
    g.id as grid_id,
    g.name as grid_name,
    g.grid_type,
    g.resolution,
    g.total_cells,
    COUNT(DISTINCT gc.id) as cells_generated,
    COUNT(DISTINCT sgi.cell_id) as cells_with_species,
    COUNT(DISTINCT f.cell_id) as cells_with_features,
    COUNT(DISTINCT cd.cell_id) as cells_with_climate,
    ROUND(
        ((COUNT(DISTINCT gc.id)::FLOAT / NULLIF(g.total_cells, 0)) * 100)::NUMERIC, 2
    ) as generation_progress_percent
FROM grids g
LEFT JOIN grid_cells gc ON g.id = gc.grid_id
LEFT JOIN species_grid_intersections sgi ON g.id = sgi.grid_id
LEFT JOIN features f ON g.id = f.grid_id
LEFT JOIN climate_data cd ON g.id = cd.grid_id
GROUP BY g.id, g.name, g.grid_type, g.resolution, g.total_cells;

CREATE VIEW experiment_summary AS
SELECT 
    e.id,
    e.name,
    e.description,
    e.status,
    e.started_at,
    e.completed_at,
    EXTRACT(EPOCH FROM (COALESCE(e.completed_at, NOW()) - e.started_at))/60 as duration_minutes,
    COUNT(pj.id) as total_jobs,
    COUNT(CASE WHEN pj.status = 'completed' THEN 1 END) as completed_jobs,
    COUNT(CASE WHEN pj.status = 'failed' THEN 1 END) as failed_jobs,
    ROUND(AVG(pj.progress_percent)::NUMERIC, 2) as avg_progress
FROM experiments e
LEFT JOIN processing_jobs pj ON e.id = pj.parent_experiment_id
GROUP BY e.id, e.name, e.description, e.status, e.started_at, e.completed_at;

-- Functions for automatic grid cell counting
CREATE OR REPLACE FUNCTION update_grid_cell_count()
RETURNS TRIGGER AS $$
BEGIN
    -- Handle INSERT
    IF TG_OP = 'INSERT' THEN
        UPDATE grids 
        SET total_cells = (
            SELECT COUNT(*) 
            FROM grid_cells 
            WHERE grid_id = NEW.grid_id
        )
        WHERE id = NEW.grid_id;
        RETURN NEW;
    END IF;
    
    -- Handle DELETE
    IF TG_OP = 'DELETE' THEN
        UPDATE grids 
        SET total_cells = (
            SELECT COUNT(*) 
            FROM grid_cells 
            WHERE grid_id = OLD.grid_id
        )
        WHERE id = OLD.grid_id;
        RETURN OLD;
    END IF;
    
    -- Handle UPDATE (if grid_id changes)
    IF TG_OP = 'UPDATE' THEN
        -- Update old grid count
        IF OLD.grid_id != NEW.grid_id THEN
            UPDATE grids 
            SET total_cells = (
                SELECT COUNT(*) 
                FROM grid_cells 
                WHERE grid_id = OLD.grid_id
            )
            WHERE id = OLD.grid_id;
        END IF;
        
        -- Update new grid count
        UPDATE grids 
        SET total_cells = (
            SELECT COUNT(*) 
            FROM grid_cells 
            WHERE grid_id = NEW.grid_id
        )
        WHERE id = NEW.grid_id;
        RETURN NEW;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for all operations
CREATE TRIGGER trigger_update_grid_cell_count
    AFTER INSERT OR UPDATE OR DELETE ON grid_cells
    FOR EACH ROW
    EXECUTE FUNCTION update_grid_cell_count();